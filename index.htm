<!DOCTYPE html>
<html lang="zh-TW">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>LINE æ‰“å¡ç³»çµ±</title>

<style>
  body { font-family: sans-serif; padding: 20px; }
  button { padding: 10px 16px; font-size: 16px; margin-right: 8px; }
  pre { background: #111; color: #0f0; padding: 10px; white-space: pre-wrap; }

  /* ===== ç°å¹• loading ===== */
  #loadingOverlay {
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.45);
    display: none;
    align-items: center;
    justify-content: center;
    z-index: 9999;
  }
  #loadingOverlay.show { display: flex; }
  .spinner {
    width: 56px;
    height: 56px;
    border: 6px solid rgba(255,255,255,0.35);
    border-top-color: #fff;
    border-radius: 50%;
    animation: spin 0.9s linear infinite;
  }
  @keyframes spin { to { transform: rotate(360deg); } }
</style>

<script>
/* ================= åŸºæœ¬è¨­å®š ================= */

const GIST_ID = "128158194ad773c072ca111b84286cfb";
const TK_HEX = "6768705F4A3052654D6C75636C6B614B785A63494C4379316C5077754458486C5150313955304361";
const REMOVE_PWD = "28814484";

const ALLOWED_LOCATIONS = [
  { name: "å°åŒ—å…¬å¸", lat: 24.986794380363925, lon: 121.5336918999006, radiusM: 200 },
  { name: "å°ä¸­è¾¦å…¬å®¤", lat: 24.310777911896015, lon: 120.72138183688088, radiusM: 2000 },
  { name: "åé‡Œç¾å…‰", lat: 24.318140260826873, lon: 120.72406839843525, radiusM: 2000 },
];

function hexToString(hex) {
  let str = '';
  for (let i = 0; i < hex.length; i += 2) str += String.fromCharCode(parseInt(hex.substr(i, 2), 16));
  return str;
}
const TOKEN = hexToString(TK_HEX);

/* ================= UIï¼šLoading ================= */

function showLoading() {
  document.getElementById("loadingOverlay").classList.add("show");
  document.getElementById("btnCheckin").disabled = true;
  document.getElementById("btnClear").disabled = true;
}
function hideLoading() {
  document.getElementById("loadingOverlay").classList.remove("show");
  document.getElementById("btnCheckin").disabled = false;
  document.getElementById("btnClear").disabled = false;
}

/* ================= å·¥å…· ================= */

function getTel() {
  let tel = localStorage.getItem("tel");
  if (!tel || !/^\d{10}$/.test(tel)) {
    tel = prompt("è«‹è¼¸å…¥ 10 ç¢¼æ‰‹æ©Ÿè™Ÿç¢¼ï¼š");
    if (!/^\d{10}$/.test(tel)) {
      alert("é›»è©±æ ¼å¼éŒ¯èª¤");
      return null;
    }
    localStorage.setItem("tel", tel);
  }
  return tel;
}

function clearTel() {
  const pwd = prompt("è«‹è¼¸å…¥ç®¡ç†å¯†ç¢¼ï¼š");
  if (pwd !== REMOVE_PWD) {
    alert("âŒ å¯†ç¢¼éŒ¯èª¤");
    return;
  }
  localStorage.removeItem("tel");
  alert("âœ… å·²æ¸…é™¤");
  location.reload();
}

function getFileName(tel) {
  return `${tel}.txt`;
}

/* ================= GPS / è·é›¢ ================= */

function distance(lat1, lon1, lat2, lon2) {
  const R = 6371e3;
  const toRad = d => d * Math.PI / 180;
  const dLat = toRad(lat2 - lat1);
  const dLon = toRad(lon2 - lon1);
  const a =
    Math.sin(dLat / 2) ** 2 +
    Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) *
    Math.sin(dLon / 2) ** 2;
  return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
}

function findNearestLocation(lat, lon) {
  let nearest = null;
  let minDist = Infinity;

  for (const loc of ALLOWED_LOCATIONS) {
    const d = distance(lat, lon, loc.lat, loc.lon);
    if (d < minDist) {
      minDist = d;
      nearest = loc;
    }
  }

  return {
    name: nearest ? nearest.name : "æœªçŸ¥ä½ç½®",
    distance: Math.round(minDist)
  };
}

/* ================= GitHub API ================= */

async function githubGET() {
  return fetch(`https://api.github.com/gists/${GIST_ID}`, {
    headers: {
      "Authorization": `token ${TOKEN}`,
      "Accept": "application/vnd.github+json"
    }
  });
}

async function githubPATCH(payload) {
  return fetch(`https://api.github.com/gists/${GIST_ID}`, {
    method: "PATCH",
    headers: {
      "Authorization": `token ${TOKEN}`,
      "Content-Type": "application/json"
    },
    body: JSON.stringify(payload)
  });
}

/* ================= ä¸»æµç¨‹ ================= */

let isCheckingIn = false;

function getLocationOnce(options) {
  return new Promise((resolve, reject) => {
    if (!navigator.geolocation) {
      reject(new Error("ç€è¦½å™¨ä¸æ”¯æ´å®šä½"));
      return;
    }
    navigator.geolocation.getCurrentPosition(
      pos => resolve(pos),
      err => reject(err),
      options
    );
  });
}

async function updateMyFile() {
  if (isCheckingIn) return;
  isCheckingIn = true;
  showLoading();
  document.getElementById("status").innerText = "";

  try {
    const tel = getTel();
    if (!tel) return;

    // å®šä½ï¼ˆåŠ  timeout é¿å…å¡ä½ï¼‰
    const pos = await getLocationOnce({
      enableHighAccuracy: true,
      timeout: 15000,
      maximumAge: 0
    });

    const lat = pos.coords.latitude;
    const lon = pos.coords.longitude;

    const nearest = findNearestLocation(lat, lon);
    const locationText = `${nearest.name} (${nearest.distance}m)`;

    const now = new Date();
    const formattedTime =
      `${now.getFullYear()}/${String(now.getMonth() + 1).padStart(2, '0')}/${String(now.getDate()).padStart(2, '0')} ` +
      `${String(now.getHours()).padStart(2, '0')}:${String(now.getMinutes()).padStart(2, '0')}:${String(now.getSeconds()).padStart(2, '0')}`;

    // ä½ æŒ‡å®šçš„æ ¼å¼ï¼š050 + time + tel + address + \r\n
    const newLine = `050\t${formattedTime}\t${tel}\t${locationText}`;

    // è®€å– Gist
    const res = await githubGET();
    if (!res.ok) throw new Error(`è®€å– Gist å¤±æ•— (${res.status})`);
    const data = await res.json();

    const fileName = getFileName(tel);
    const old = data.files[fileName]?.content || "";

    // æ¸…é™¤ 90 å¤©å‰
    const nowTime = Date.now();
    const ninetyDaysMs = 90 * 24 * 60 * 60 * 1000;

    const filtered = old
      .split("\n")
      .map(l => l.trim())
      .filter(line => {
        if (!line) return false;
        const parts = line.split("\t");
        if (parts.length < 2) return false;
        const t = Date.parse(parts[1]);
        return !isNaN(t) && (nowTime - t <= ninetyDaysMs);
      });

    filtered.unshift(newLine);

    // å­˜æª”ç”¨å…§å®¹ï¼ˆç”¨ \r\n é€£æ¥æ›´ç¬¦åˆä½ åŸæœ¬ç¿’æ…£ï¼‰
    const content = filtered.join("\r\n");

    // å¯«å› GitHub
    const patchRes = await githubPATCH({
      files: { [fileName]: { content } }
    });

    if (!patchRes.ok) throw new Error(`å¯«å…¥å¤±æ•— (${patchRes.status})`);

    document.getElementById("status").innerText = "âœ… æ‰“å¡æˆåŠŸ";
    document.getElementById("records").textContent = content;

  } catch (err) {
    const msg = (err && err.message) ? err.message : String(err);
    alert("âŒ æ‰“å¡å¤±æ•—ï¼š" + msg);
    document.getElementById("status").innerText = "âŒ æ‰“å¡å¤±æ•—";
  } finally {
    hideLoading();
    isCheckingIn = false;
  }
}

async function loadMyFile() {
  const tel = getTel();
  if (!tel) return;

  try {
    const res = await githubGET();
    if (!res.ok) return;
    const data = await res.json();

    const file = data.files[getFileName(tel)];
    if (file) document.getElementById("records").textContent = file.content;
  } catch {
    // ä¸åµä½¿ç”¨è€…
  }
}

/* ================= å•Ÿå‹• ================= */
window.onload = () => {
  loadMyFile();
};
</script>
</head>

<body>

<!-- ç°å¹• loading -->
<div id="loadingOverlay" aria-hidden="true">
  <div class="spinner" aria-label="loading"></div>
</div>

<h2>ğŸ“ 2026æ‰“å¡ç³»çµ±</h2>

<button id="btnCheckin" onclick="updateMyFile()">æ‰“å¡</button>
<button id="btnClear" onclick="clearTel()">æ›é›»è©±</button>

<p id="status"></p>

<h3>ğŸ“„ æˆ‘çš„ç´€éŒ„</h3>
<pre id="records"></pre>

</body>
</html>
